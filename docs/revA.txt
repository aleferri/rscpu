
PC - 16 bit  -- Visible, Program Counter
AC - 16 bit  -- ACcumulator register
DR - 16 bit  -- Data Register, contains the read data
TR - 16 bit  -- Temp Register, contains AC at the beginning of each instruction
AR - 16 bit  -- Argument Register
MA - 16 bit  -- Memory Address Register
IR - 04 bit  -- Instruction Register, contains the 4 bits opcode 

Changes:
    - ALU take 2 bits from IR, but the flow of uops is the same, put a 4 bit field in the first byte to codify ALU function and group all instructions in two families, ALU immediate and ALU memory
    - deprecated LIT for removal
    - Make the opcodes in ALU: ADD, MOV, SUB, CMP, AND, XOR, ORA, NOR
    
    
FETCH IR, AR -> MASK_AR_10, MASK_AR_12

MASK_AR_10 = IS_ALU
MASK_AR_12 = RST_MASK

address = 
    1 bit addressing mode: 
        0 -> Absolute
        1 -> PC Relative
    
    10/11 bit address/offset
    
  
ALU @ : 00ff address( 12 bit )                      EA = PC + offset / address      AGU(0: PC * E, 1: ARG[9:0])                  
    
    IR <- MEM[PC], AR <- MEM[PC], DR <- MEM[PC];
    DR <- MEM[PC], PC <- PC + 1;
    AC <- AC op DR
    
INC @ : 0100 address( 12 bit )                      EA = PC + offset / address      AGU(0: PC * E, 1: ARG[10:0])

    IR <- MEM[PC], AR <- MEM[PC]; 
    DR <- MEM[AR]; 
    TR <- DR + 1;
    MEM[AR] <- TR;
    
SHR @ : 0111 address( 12 bit )                      EA = PC + offset / address      AGU(0: PC * E, 1: ARG[10:0])

    IR <- MEM[PC], AR <- MEM[PC];
    DR <- MEM[AR];
    TR <- DR >> 1;
    MEM[AR] <- TR;

JMP @ : 1000 address( 12 bit )                      EA = PC + offset / address      AGU(0: PC * E, 1: ARG[10:0])

    IR <- MEM[PC], AR <- MEM[PC]; 
    PC <- AR;

JZE @ : 1010 address( 12 bit )                      EA = PC + offset / address      AGU(0: PC * E, 1: ARG[10:0])

    IR <- MEM[PC], AR <- MEM[PC]; 
    PC <- AR IF AC == 0;
    
LDA @ : 1100 address( 12 bit )                      EA = PC + offset / address      AGU(0: PC * E, 1: ARG[10:0])

	IR <- MEM[PC], AR <- MEM[PC];
    DR <- MEM[AR];
    AC <- MEM[AR]; TR <- MEM[AR];
    
LDI @ : 1101 address( 12 bit )                      EA = MEM[PC + offset / address]      AGU(0: PC * E, 1: ARG[10:0]); AR <- MEM; AGU(0: 0, 1: ARG[15:0])

	IR <- MEM[PC], AR <- MEM[PC];
    AR <- MEM[AR];
    AC <- MEM[AR]; TR <- MEM[AR];

STA @ : 1110 address( 12 bit )                      EA = PC + offset / address      AGU(0: PC * E, 1: ARG[10:0])

    IR <- MEM[PC], AR <- MEM[PC]; 
    MEM[AR] <- TR;
	
STI @ : 1111 address( 12 bit )                      EA = MEM[PC + offset / address]      AGU(0: PC * E, 1: ARG[10:0]); AR <- MEM; AGU(0: 0, 1: ARG[15:0])

	IR <- MEM[PC], AR <- MEM[PC]; 
    AR <- MEM[AR];
	MEM[AR] <- TR;


BUS_0 := connect( AR(read), DR(read), IR(read), MEM_D_IN(write) );                      BUS_0 has only one writer (MEM_D_IN)
BUS_1 := connect( MAR(write), MEM_ADR(read) );                                          BUS_1 has only one wirter (MAR), and one reader (MEM_ADR)
BUS_2 := connect( TR(read), AC(read/write), ALU(write), DR(write), DR_UNY(write) );     BUS_2 has four writers (ALU, AC, DR, DR_URY) and two readers (TR & AC)


Signals

AR_RB0          AR <- BUS_0
DR_RB0          DR <- BUS_0
IR_RB0          IR <- BUS_0
PC_RB1          PC <- BUS_1
PC_WB1          PC -> BUS_1
AR_WB1          AR -> BUS_1
TR_RB2          TR <- BUS_2
AC_RB2          AC <- BUS_2
FN_WB2          FN -> BUS_2     ( ALU binary operations )
DR_WB2          DR -> BUS_2
UN_WB2          UN -> BUS_2     ( Unary operations )
ALU_MUX         ALU <- select( AC + DR, AC & DR, AC nor DR )
W_MEM           MEM[ MEM_ADR ] <- TR
PC_INC          PC <- PC + 1



Registers Signals:


IR signals:
IR_LOAD_0 = OP_LOAD_0

AR signals:
AR_LOAD_0
AR_OUTP_1

DR signals:
DR_LOAD_0
DR_OUTP_2

PC signals:
PC_LOAD_1

TR signals:
TR_LOAD_2

AC signals:
AC_LOAD_2
AC_OUTP_2

FN signals:
FN_OUTP_2
FN_MUX

UN signals:
UN_MUX
UN_OUTP_2



Direct links

AC          -> ALU_PORT_0
DR          -> ALU_PORT_1
TR          -> MEM_D_OUT
MAR         -> MEM_A_OUT
IR[1:0]     -> UN_MUX
OP[3:0]     -> FN_MUX




Microcontrol States

INIT0 : EA = const(400h); MAR = EA; PC = EA
INIT1 : FETCH;
INIT2 : DISPATCH; EA = abs|rel(IR); MAR = EA;   <prevent dispatch if JZE and ac is not z>
INIT3 : EA = inc; MAR = EA; PC = EA; END_FETCH

ALU0 : DR = MEM; EA = inc; PC = EA; MAR = EA; 
ALU1 : AC = AC op DR; FETCH; END_DISPATCH

INC0 : DR = MEM;
INC1 : TR = unary DR;
INC2 : WMEM; TR = AC; EA = inc; PC = EA; MAR = EA; END_FETCH

SHR0 : DR = MEM;
SHR1 : TR = unary DR;
SHR2 : WMEM; TR = AC; EA = inc; PC = EA; MAR = EA; END_FETCH

JMP0 : EA = abs|rel(IR); PC = EA; FETCH; END_DISPATCH

JZE0 : EA = abs|rel(IR); PC = EA; FETCH; END_DISPATCH

LDA0 : DR = MEM; EA = inc; PC = EA; MAR = EA;
LDA1 : AC = DR; FETCH; END_DISPATCH

LDI0 : ARG = MEM;
LDI1 : EA = ABS; MAR = EA;
LDI2 : DR = MEM; EA = inc; MAR = EA; PC = EA;
LDI3 : AC = DR; FETCH; END_DISPATCH

STA0 : WMEM; EA = inc; PC = EA; MAR = EA; END_FETCH

STI0 : ARG = MEM;
STI1 : EA = ABS; MAR = EA;
STI2 : WMEM; EA = inc; MAR = EA; PC = EA; END_FETCH

uop = j<2> fetch larg | ea_uop<2> lpc lmar | ldr lac ltr w_mem | bm2<2> free<2>